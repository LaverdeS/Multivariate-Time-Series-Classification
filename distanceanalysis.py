# -*- coding: utf-8 -*-
"""DistanceAnalysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1v5VPG-3UBviGz-OiL8sfB91scTQGInNV
"""

# Data analysis https://www.youtube.com/watch?v=a9UrKTVEeZA&ab_channel=CSDojo
#DataCleaning https://www.youtube.com/watch?v=KdmPHEnPJPs&ab_channel=CoreySchafer

import pandas as pd
import numpy as np
import json
from matplotlib import pyplot as plt

"""#Method

"""

from google.colab import drive
drive.mount('/content/drive')

import numpy as np
import plotly.express as px
import matplotlib.pyplot as plt
from IPython.display import HTML
import json



# Help Functions

def print_yellow(text): print("\033[93m {}\033[00m".format(text))


def print_bold(text): print(f"\033[1m {text} \033[0m")


def read_json(path):
  with open(path, 'r') as file_in:
     return json.load(file_in)


def line_equation(a, b):
    """calculates y=mx+b from two points, return m, b"""
    m = (b[1] - a[1]) / (b[0] - a[0])
    b_ = b[1] - m * b[0]
    return m, b_


def normal_projection_from_points(p1, p2, p3):
  p1 = np.asarray(p1)
  p2 = np.asarray(p2)
  p3 = np.asarray(p3)
  return np.linalg.norm(np.cross(p2 - p1, p1 - p3)) / np.linalg.norm(p2 - p1)

# Line to Point Distance Methods

def ideal_lines(patterns):
  lines = {}
  for ix, (k, v) in enumerate(patterns.items()):
          if k not in lines.keys():
            lines.update({k: []})
          try:
            lines[k].append((v[ix], v[ix+1]))
            lines[k].append((v[ix+1], v[ix+2]))
            lines[k].append((v[ix+2], v[ix+3]))
          except IndexError:
            pass
  return lines


def calculate_subject_distance_alt(lines_dict, subject_dpoints):
  distances = []
  for pattern, data_points in subject_dpoints.items():
      for data_point in data_points:
          shortest_distance = 99999
          for line in lines_dict[pattern]:
            distance = normal_projection_from_points(line[0], line[1],data_point)
            if distance < shortest_distance:
              shortest_distance = distance
          distances.append(shortest_distance)
  
  return distances


def extract_coordinates(data):
  patterns = {'Z': [], 'N': []}
  for v in data['Items']:
    # print(f"{v}")
    for k, v_ in v.items():
      if k == "gaze_valid":
        coord = list(v_.values())
        # print(coord + "\n")
        if any(c == 0 for c in coord):
          pass
        else:
          patterns[working_pattern].append((coord[0], coord[1]))
  return patterns


def extract_coordinates2(data, working_pattern):
  patterns = {'pattern1': [], 'pattern2': [], 'pattern3': [], 'pattern4': [], 'pattern5': [], 'pattern6': []}
  for v in data['Items']:
    # print(f"{v}")
    for k, v_ in v.items():
      if k == "gaze_valid":
        coord = list(v_.values())
        # print(coord + "\n")
        if any(c == 0 for c in coord):
          pass
        else:
          patterns[working_pattern].append((coord[0], coord[1]))
  return patterns

"""#Solution

"""

from google.colab import drive
drive.mount('/content/drive', force_remount=True)

data_path = '/content/drive/MyDrive/JSON_Jahed/JsonJahed'

pattern_seq_dict = {'pattern1': ['circle_1', 'circle_2', 'circle_3', 'circle_6', 'circle_9', 'circle_8', 'circle_7'],
                         'pattern2': ['circle_1', 'circle_4', 'circle_7', 'circle_8', 'circle_9', 'circle_6', 'circle_3'],
                         'pattern3': ['circle_1', 'circle_4', 'circle_7', 'circle_5', 'circle_3', 'circle_6', 'circle_9'],
                         'pattern4': ['circle_1', 'circle_2', 'circle_3', 'circle_5', 'circle_7', 'circle_8', 'circle_9'],
                         'pattern5': ['circle_1', 'circle_5', 'circle_9', 'circle_6', 'circle_3', 'circle_7'],
                         'pattern6': ['circle_1', 'circle_5', 'circle_9', 'circle_8', 'circle_7', 'circle_3']}


def translate_data2pattern(data, pattern_seq_dict, verbose=False):
  patterns_order = []
  for k, v in data.items():
    for ix, round in enumerate(v):
      for k, v_ in round.items():
        if k == 'pattern':
          if verbose:
            print(f"{ix}: {v_}", end=" -----> ")
          for pattern, seq in pattern_seq_dict.items():
            if v_ == seq:  # you found a match with a pattern
              if verbose:
                print(pattern)
              patterns_order.append(pattern)
              break
  return patterns_order

data_test = read_json('/content/drive/MyDrive/Thesis/JsonJahed/Analysis/Participants/Arif/WrongAttempts.txt')
patterns_label = translate_data2pattern(data_test, pattern_seq_dict)
print(patterns_label)

patterns = {'pattern1': ((0.25, 0.15), (0.75, 0.15), (0.75, 0.85), (0.25, 0.85)),   # reverse C
            'pattern2': ((0.25, 0.15), (0.25, 0.85), (0.75, 0.85), (0.75, 0.15)),   # U
            'pattern3': ((0.25, 0.15), (0.25, 0.85), (0.75, 0.15), (0.75, 0.85)),   # reverse N
            'pattern4': ((0.25, 0.15), (0.75, 0.15), (0.25, 0.85), (0.75, 0.85)),   # Z
            'pattern5': ((0.25, 0.15), (0.75, 0.85), (0.75, 0.15), (0.25, 0.85)),   # X_1
            'pattern6': ((0.25, 0.15), (0.75, 0.15), (0.25, 0.85), (0.75, 0.15))}   # X_2

print(len(patterns_label))
pattern_coords = [patterns[pattern] for pattern in patterns_label]   # ideal pattern cords for number of samples

for l, v in zip(patterns_label, pattern_coords):
  print(f"{l}: {v}")

import os
from tqdm import tqdm

def fileList(source):
    matches = []
    for root, dirnames, filenames in os.walk(source):
        for filename in filenames:
            if filename.endswith(('.txt')):
                matches = matches + [(os.path.join(root, filename))] if ("Gaze" in filename) else matches
      
    return matches

path = '/content/drive/MyDrive/Thesis/JsonJahed/Analysis/Participants/Arif'

print("files inside Arif folder: \n_____________________________")
files = sorted(fileList(path))
print("number of files: ", len(files))

print("truth path (WrongAttempts): ", path + '/WrongAttempts.txt')
data_truth = read_json(path + '/WrongAttempts.txt')   # '/content/drive/MyDrive/JSON_Jahed/JsonJahed/Analysis/Participants/Arif/WrongAttempts.txt'

patterns_label_truth = translate_data2pattern(data_truth, pattern_seq_dict)
print("number of truth values: ", len(patterns_label))
print()

assert len(patterns_label) == len(files); "Number of samples does not match"

number_of_desired_plots = 0
distances_collection = []
verbose = False


#jahed
coords_subj_collection = []




for ix, (f_path, pattern_label) in tqdm(enumerate(zip(files, patterns_label))):
  name = f_path[-14:].replace("/", "")
  
  data = read_json(f_path)
  
  coords_subj = extract_coordinates2(data, pattern_label)  # data == subject_patterns
  coords_subj = {pattern_label: coords_subj[pattern_label]}


  if verbose:
    print("filepath: ", name)
    print("\ndata: ", data)
    print("pattern_label", pattern_label)
    print("coords_subj for this label: ", coords_subj)

  # build the lines dict for each label_seq
  lines_dict = ideal_lines({pattern_label: patterns[pattern_label]})
  distances = calculate_subject_distance_alt(lines_dict, coords_subj)

  if verbose:
    print("pattern --> ", {pattern_label: patterns[pattern_label]})
    print("lines_dict for this label: ", lines_dict)
    print("\ndistances: ")
    print_yellow(distances)

  distances_collection.append((pattern_label, distances))



#jahed
  coords_subj_collection.append((pattern_label, coords_subj))

  # print(len(patterns_label))
  pattern_coords = [patterns[pattern] for pattern in patterns_label]   # ideal pattern cords for number of samples

  #print(f"name: {name} ; number of samples: {len(pattern_coords)}")
  # for l, v in zip(patterns_label, pattern_coords):
  #   print(f"{l}: {v}")
  # plotty express
  X = [dpoint[0] for dpoint in list(coords_subj.values())[0]]
  
  if number_of_desired_plots:
    if ix == number_of_desired_plots:
      print()
      break
  
def plot_derivative(plot_only_this:str, derivative, number_of_desired_plots=0):
  fig = go.Figure()
  plots_count = 0
  print("total number of graphs: ", len(derivative))

  for (pattern_name, d) in derivative:
    if pattern_name == plot_only_this:
      if plots_count ==0:
        # fig = px.line(y=d)
        fig.add_trace(go.Line(y=d))
        fig.update_layout(title=plot_only_this)
      else:
        # fig.add_scatter(y=d, mode="lines")
        fig.add_trace(go.Line(y=d))
        
      plots_count += 1

      # fig.update_traces(marker_color='red')
      fig.update_layout(width=1200, height=800)
      # fig.show()
      if number_of_desired_plots:
        if plots_count == number_of_desired_plots:
          break

  print("plots: ", plots_count)
  HTML(fig.to_html())
  return fig
# TEST
import plotly.graph_objects as go

def plot_collection(plot_only_this:str, distances_collection, number_of_desired_plots=0):
  fig = go.Figure()
  plots_count = 0
  print("total number of graphs: ", len(distances_collection))

  for (pattern_name, d) in distances_collection:
    if pattern_name == plot_only_this:
      if plots_count ==0:
        # fig = px.line(y=d)
        fig.add_trace(go.Line(y=d))
        fig.update_layout(title=plot_only_this)
      else:
        # fig.add_scatter(y=d, mode="lines")
        fig.add_trace(go.Line(y=d))
        
      plots_count += 1

      # fig.update_traces(marker_color='red')
      fig.update_layout(width=1200, height=800)
      # fig.show()
      if number_of_desired_plots:
        if plots_count == number_of_desired_plots:
          break

  print("plots: ", plots_count)
  HTML(fig.to_html())
  return fig

# todo: add label to distances_collection (I could use a tuple); filter by pattern; delete the breaking points by the number_of_desired_plots

"""#output"""

my_figure = plot_collection("pattern1", distances_collection)
HTML(my_figure.to_html())